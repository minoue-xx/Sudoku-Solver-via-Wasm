function Imask = solveSudokuImage_codegen(Icam) %#codegen
% This function returns an image with a solution of Sudoku puzzle overlayed
% to the original (but transformed) image.
% Modifications are made so that the functions can be C-coge generated by
% MATLAB Coder but the baseline is taken from the work by Teja Muppirala and can be found here: 
% Video Sudoku Solver version 1.7.0.1
% https://jp.mathworks.com/matlabcentral/fileexchange/30088-video-sudoku-solver
%
% Input: Icam (1x[3*width*length])
% Image of the Sudoku Puzzle in a format of 1x[3*width*length]. This is
% because the function is intented to be used within javascript.
% Here we assume that the image size is N x N (N = 750)
%
% Output: Imask (1x[4*width*length])
% The image of solution is overlayed to the input image. Please note that
% the output is a vector and it contains the fourth element (alpha) besizes rgb.
% Copyright (c) 2021 Michio Inoue

%% For debugging:
% If needed to check the function with the pre-recorded image, use the
% following.
% 
% Icam = imread('photoEx4.jpg');
%
% OR In C-code gen mode (The image saved to sampleImage.mat)
% s = coder.load("sampleImage.mat","Icam");
% Icam = s.Icam;
% Icam = imresize(Icam,[750,750]);
%
%% Reformat the image data
N = 750;
Icam = reshape(Icam,[3,N,N]);
Icam = permute(Icam,[3,2,1]);

%% Convert to gray image
Ibw = rgb2gray(Icam); % codegen ok

%% Convert to Black and White / ２値化処理
Ibw = ~imbinarize(Ibw,'adaptive', ...
    'ForegroundPolarity','dark', ...
    'Sensitivity',0.4); % codegen ok

%% Remove Noise / ノイズ除去
thNoise = numel(Ibw)*0.0001; % 0.01%
Ibw = bwareaopen(Ibw,floor(thNoise)); % code gen ok

%% Clear the border / 外とつながっている部分を除去
Ibw = imclearborder(Ibw); % code gen ok

%% Find the largest box / 一番大きい枠を探す
R = regionprops(Ibw,'Area','BoundingBox','PixelList');
% code gen ok

areaMax = 0;
kmax = 0;
for ii=1:length(R)
    if areaMax < R(ii).Area
        areaMax = R(ii).Area;
        kmax = ii;
    end
end

tmpR = R(kmax);
tmp = tmpR.PixelList;
DIAG1 = sum(tmp,2);
DIAG2 = diff(tmp,[],2);

[~,dUL] = min(DIAG1);    [~,dDR] = max(DIAG1);
[~,dDL] = min(DIAG2);    [~,dUR] = max(DIAG2);

pts = tmpR.PixelList([dUL dDL dDR dUR dUL],:);

%% Check if a reasonable box is detected
fixedPoints = [1 1; 9 1; 9 9; 1 9]/10.*size(Ibw);
movingPoints = pts(1:4,:);
boxarea = polyarea(movingPoints(:,1),movingPoints(:,2));

% if the area of the detected box is less than 10% of the input image,
% assume that no sudoku puzzle is detected. Then the function returns the
% input image.
if boxarea/(N*N) < 0.1
    tmp = cat(3,Icam,zeros(N,N,1,'uint8'));
    tmp = permute(tmp,[3,2,1]);
    Imask = tmp(:);
    return
end

% If a box is detected, then project the box to square box, this is to
% ease detection of the digits in 81x81 boxes.
transformationType = "projective";
tform = fitgeotrans(movingPoints,fixedPoints, ...
    transformationType); % code gen ok % error occurs here for bad images

Ibw_warp = imwarp(Ibw,tform); % code gen ok
Icam_warp = imwarp(Icam,tform); % code gen ok

%% Again, Find the largest box / 再度一番大きい枠を探す
% Just to be sure repeat the process of finding the box.
R = regionprops(Ibw_warp,'Area','BoundingBox','PixelList');
% code gen ok

areaMax = 0;
kmax = 0;
for ii=1:length(R)
    if areaMax < R(ii).Area
        areaMax = R(ii).Area;
        kmax = ii;
    end
end

tmpR = R(kmax);
tmp = tmpR.PixelList;
DIAG1 = sum(tmp,2);
DIAG2 = diff(tmp,[],2);

[~,dUL] = min(DIAG1);    [~,dDR] = max(DIAG1);
[~,dDL] = min(DIAG2);    [~,dUR] = max(DIAG2);

pts = tmpR.PixelList([dUL dDL dDR dUR dUL],:);

%% Only keep elements in the boxes / ますに入っている要素のみキープ
% Equally devide the box to 81x81 smaller boxes and separately keep the
% pixcel with in each small box.
% code gen ok
data = cell(9,9);
xx = linspace(pts(1,1),pts(2,1),10);
yy = linspace(pts(2,2),pts(3,2),10);
for ii=1:9
    for jj=1:9
        tmp = imcrop(Ibw_warp,[xx(ii),yy(jj),...
            xx(ii+1)-xx(ii), yy(jj+1)-yy(jj)]); % code gen ok
        % Clear border
        data{ii,jj} = imclearborder(tmp); % code gen ok
    end
end


% sizes = cellfun(@(x) sum(x,'all'),data(:));
% cellfun is not supported so the following.
sizes = zeros(81,1);
for ii=1:81
    sizes(ii) = sum(data{ii},'all');
end
% Check the median size of digits (number of pixcel)
medianSize = median(sizes(sizes>0));

%% Identify the digits within the box
% code gen ok
digits = zeros(81,1);
for ii=1:81
    image = data{ii};

    % if the detected pixcel is smaller than the 10% of the median size,
    % consider it as noise and returns 0 (no digit)
    if sum(image,'all') < medianSize/10
        digits(ii) = 0;
    else
        % Otherwise, use CNN (input layer assumes the image size 56x56) to
        % identify the digit.
        image = imresize(image,[56,56]);

        % To increase robustness, 
        % 1. move the detected image to the center of the image.
        E = regionprops(image,'Centroid');
        Tx = 28-E(1).Centroid(1);
        Ty = 28-E(1).Centroid(2);
        image = imtranslate(image,[Tx Ty]);

        % 2. modify the image to create 5 versions and take the mode to
        % make the final decision.
        % Note that the expected input for the CNN is uint8. 
        % Since image is binary image, the image is multipled by 255.

        % prediction for the original image
        out = digitPredictFcn_CNN(double(image(:))*255);
        [~,cnnpred0] = max(out);

        % prediction for the image (x-translated)
        image1 = imtranslate(image,[5 0]);
        out = digitPredictFcn_CNN(double(image1(:))*255);
        [~,cnnpred1] = max(out);

        % prediction for the image (y-translated)
        image2 = imtranslate(image,[0 5]);
        out = digitPredictFcn_CNN(double(image2(:))*255);
        [~,cnnpred2] = max(out);

        % prediction for the image (rotated 1)
        image3 = imrotate(image,10,'crop');
        out = digitPredictFcn_CNN(double(image3(:))*255);
        [~,cnnpred3] = max(out);

        % prediction for the image (rotated 2)
        image4 = imrotate(image,-10,'crop');
        out = digitPredictFcn_CNN(double(image4(:))*255);
        [~,cnnpred4] = max(out);

        % Take mode to make the final decision.
        cnnpred = mode([cnnpred0,cnnpred1,cnnpred2,cnnpred3,cnnpred4]);
        digits(ii) = cnnpred-1;
    end
end

%% Calculate the Solution / ソリューションを計算する
% code gen ok
M = reshape(digits,[9,9])';
M_sol = Sudoku(M);

%% Generate an image from the solution / ソリューションから画像を作成
I = solution2image_codegen(M,M_sol);

%% Overlay the solution on the original image / 画像をオーバレイ
Iresize = imresize(~I,[pts(3,2)-pts(2,2),pts(2,1)-pts(1,1)]);
Imask = zeros(size(Icam_warp));
Imask(pts(2,2):pts(3,2)-1, pts(1,1):pts(2,1)-1,2) = Iresize;
Imask = Icam_warp .* uint8(~Imask);
Imask = imresize(Imask,[N,N]);

% Reshape the image for the later use (javascript)
tmp = cat(3,Imask,zeros(N,N,1,'uint8'));
tmp = permute(tmp,[3,2,1]);
Imask = tmp(:);